import type { Metadata } from "next";
import "bootstrap/dist/css/bootstrap.css";
import '@/App.css'
import { getData, getEndpointData } from "@/lib/api";
import { getIdFromURL, getNameByLanguage } from "@/lib/util";
import { type Locale } from "@/i18nConfig";
import TranslationsProvider from "@/components/transition-provider";
import initTranslations from "@/lib/i18n";
import { AppRouterCacheProvider } from "@mui/material-nextjs/v14-appRouter";
import TransitionProvider from "@/components/transition-context";
import AOSInitializer from "@/components/aos-initializer";
import Loader from "@/components/loader";
import { dir } from 'i18next';
import {i18nNamespaces} from '@/i18nConfig'
export const metadata: Metadata = {
	title: "Pokedex",
	description: "Pokedex App Generated by create next app",
};


import {
	CachedAllPokemonNamesAndIds,
	CachedPokemonSpecies,
} from "@/slices/pokemon-data-slice";
import NavBar from "@/components/navbar";

type RootLayoutProps = {
	children: React.ReactNode;
	params: {
		locale: Locale;
	};
};
export default async function Layout({
	children,
	params: { locale },
}: RootLayoutProps) {
	const {resources} = await initTranslations(locale, i18nNamespaces);

	const generationResponse = await getEndpointData("generation");
	const generations = await getData(
		"generation",
		generationResponse.results.map((entry) => entry.name),
		"name"
	);

	// types
	const typeResponse = await getEndpointData("type");
	const types = await getData(
		"type",
		typeResponse.results.map((entry) => entry.name),
		"name"
	);

	let speciesData: CachedPokemonSpecies,
		pokemonsNamesAndId: CachedAllPokemonNamesAndIds;
	const speciesResponse = await getEndpointData("pokemonSpecies");

	if (locale !== "en") {
		speciesData = await getData(
			"pokemonSpecies",
			speciesResponse.results.map((entry) => getIdFromURL(entry.url)),
			"id"
		);
		pokemonsNamesAndId = Object.values(
			speciesData
		).reduce<CachedAllPokemonNamesAndIds>((pre, cur) => {
			pre[getNameByLanguage(cur.name, locale, cur)] = cur.id;
			return pre;
		}, {});
	} else {
		pokemonsNamesAndId =
			speciesResponse.results.reduce<CachedAllPokemonNamesAndIds>(
				(pre, cur) => {
					pre[cur.name] = getIdFromURL(cur.url);
					return pre;
				},
				{}
			);
	}


// prefetch data at build time, if we don't do this, sorting pokemons through weight/height... will cause routing unresponsive for a while (select --> nothing happens --> a while later --> url changes --> suspense fallback shows)
	// const responses = await Promise.all([...Array(1000).keys()].map(num => fetch(`https://pokeapi.co/api/v2/pokemon/${num + 1}`, {cache: 'force-cache'})));
	// const speciesResponse = await getEndpointData("pokemonSpecies");
	// const intersection = speciesResponse.results.map((entry) => getIdFromURL(entry.url))

	// const unresolvedPokemons = getData("pokemon", intersection, "id");
	// 	const unresolvedSpeciesData = getData("pokemonSpecies", intersection, "id");
	// 	await Promise.all([unresolvedPokemons, unresolvedSpeciesData]);


	return (
		<html lang={locale} dir={dir(locale)}>
			{/* <body className={zen_maru_gothic.className}> */}
			<body>
				{/* {props.search} */}
				<AOSInitializer />
				<TransitionProvider>
					<Loader />
					<AppRouterCacheProvider>
						<TranslationsProvider
							namespaces={i18nNamespaces}
							locale={locale}
							resources={resources}
						>
							<NavBar
								generations={generations}
								types={types}
								namesAndIds={pokemonsNamesAndId}
							/>
							{children}
						</TranslationsProvider>
					</AppRouterCacheProvider>
				</TransitionProvider>
			</body>
		</html>
	);
}



// using provider will probably not affect the rendering of the components, only the children will still be rendered on the server, but the component that read the context (usexxx hook) will be rendered on the client.

// configure documnet file?
// https://nextjs.org/docs/getting-started/installation#the-pages-directory-optional
// https://mui.com/material-ui/guides/nextjs/#typescript




	
	// in a client component, reading params, i.e. const params = useParams() and when the route changes, this component will re-rendered because of "context changed"
	// also notice that the returned value of useParams is not cached:
	// this happen when i was in /en/pokemons, and when search params changes, I still get the same params {language: 'en}, but not the same instance,
	// when I was in /en/pokemon/xxx, change to different pokemon, the params will cahange from for example: {language: 'en', id: 1} to  {language: 'en', id: 2}, in case like this, you say the context changed is understandable, but in the above case, it doesn't quite make sense.
	// one of a workaround is pass language from the server to the client, but later I will migrate to i18n, then I'll see if the same problem exists.